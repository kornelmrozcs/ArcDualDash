#pragma once

#include "CoreMinimal.h"
#include "WheeledVehiclePawn.h"
#include "InputActionValue.h"
#include "ChaosVehicleMovementComponent.h"
#include "MyCar.generated.h"

UCLASS()
class ARCDUALDASH_API AMyCar : public AWheeledVehiclePawn
{
	GENERATED_BODY()

public:
	AMyCar();
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaSeconds) override;
	virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;

	// --- Input (P1) ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputMappingContext* DefaultMappingContext;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputAction* MoveAction;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputAction* HandbrakeAction;

	void Move(const FInputActionValue& Value);
	void MoveEnd();
	void OnHandbrakePressed();
	void OnHandbrakeReleased();

	// --- Race laps ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Race|Laps")
	int32 Lap = 1;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Race|Laps")
	int32 CurrentCheckpoint = 0;

	UFUNCTION(BlueprintCallable, Category = "Race|Laps")
	void LapCheckpoint(int32 _CheckpointNo, int32 _MaxCheckpoint, bool _bStartFinishLine);

	// --- Keyboard proxy for P2 ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputMappingContext* ProxyMappingContext_P2 = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputAction* MoveAction_P2 = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputAction* HandbrakeAction_P2 = nullptr;

	void Move_P2(const FInputActionValue& Value);
	void MoveEnd_P2();
	void OnHandbrakePressed_P2();
	void OnHandbrakeReleased_P2();

	// --- PowerUps / Score ---
	UFUNCTION(BlueprintCallable, Category = "PowerUp")
	void StartSpeedBoost(float DurationSeconds = 2.5f, float Force = 1800000.f);

	UFUNCTION(BlueprintCallable, Category = "PowerUp")
	void EndSpeedBoost();

	UFUNCTION(BlueprintCallable, Category = "Score")
	int32 AddScore(int32 Delta);

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostForce = 1000.f;

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostDragScale = 0.6f;

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostDurationDefault = 2.5f;

	// Allow Checkpoints to update our last checkpoint
	void SetLastCheckpoint(AActor* CheckpointActor) { LastCheckpoint = CheckpointActor; }

private:
	// --- Boost internals ---
	bool bBoostActive = false;
	float SavedDragCoefficient = 0.f;
	FTimerHandle BoostTimer;
	int32 Score = 0;

	// --- Crash + Respawn ---
	// Hit fired by CrashTrigger (or any component we bind)
	UFUNCTION()
	void OnCarHit(UPrimitiveComponent* HitComp, AActor* OtherActor,
		UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);

	// Global actor hit fallback
	UFUNCTION()
	void OnAnyActorHit(AActor* SelfActor, AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit);

	// Overlap fallback (when hits/impulses aren’t generated by the track mesh)
	UFUNCTION()
	void OnCrashTriggerOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
		UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& Sweep);

	UFUNCTION()
	void HandleCarCrash();

	UFUNCTION()
	void RespawnCar();

	// FX / settings
	UPROPERTY(EditAnywhere, Category = "Crash|Effects")
	UParticleSystem* ExplosionFX = nullptr;

	// Thresholds (tune in editor)
	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float CrashForceThreshold = 80000.f; // impulse from hit

	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float CrashSpeedThreshold = 1800.f;  // cm/s for overlap fallback (~18 m/s ≈ 65 km/h)

	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float RespawnDelay = 2.0f;

	UPROPERTY()
	bool bIsCrashed = false;

	// Last checkpoint to respawn at
	UPROPERTY()
	AActor* LastCheckpoint = nullptr;
};
