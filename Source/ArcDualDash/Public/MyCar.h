#pragma once

#include "Checkpoints.h"
#include "CoreMinimal.h"
#include "WheeledVehiclePawn.h"
#include "InputActionValue.h"
#include "ChaosVehicleMovementComponent.h"
#include "MyCar.generated.h"

UCLASS()
class ARCDUALDASH_API AMyCar : public AWheeledVehiclePawn
{
	GENERATED_BODY()

public:
	AMyCar();
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaSeconds) override;
	virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;

	// --- Input (P1) ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputMappingContext* DefaultMappingContext;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputAction* MoveAction;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	class UInputAction* HandbrakeAction;

	void Move(const FInputActionValue& Value);
	void MoveEnd();
	void OnHandbrakePressed();
	void OnHandbrakeReleased();

	// --- Race laps / checkpoints ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Race|Laps")
	int32 Lap = 1;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Race|Laps")
	int32 CurrentCheckpoint = 0;

	UFUNCTION(BlueprintCallable, Category = "Race|Laps")
	void LapCheckpoint(int32 _CheckpointNo, int32 _MaxCheckpoint, bool _bStartFinishLine);

	// --- Leaderboard tracking ---
	UPROPERTY(BlueprintReadOnly, Category = "Race|Progress")
	int32 CurrentCheckpointIndex = 0;

	UPROPERTY(BlueprintReadOnly, Category = "Race|Progress")
	float DistanceToNextCheckpoint = 0.f;

	UPROPERTY()
	TArray<ACheckpoints*> AllCheckpoints;

	// --- Keyboard proxy for P2 ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputMappingContext* ProxyMappingContext_P2 = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputAction* MoveAction_P2 = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input|P2")
	class UInputAction* HandbrakeAction_P2 = nullptr;

	void Move_P2(const FInputActionValue& Value);
	void MoveEnd_P2();
	void OnHandbrakePressed_P2();
	void OnHandbrakeReleased_P2();

	// --- PowerUps / Score ---
	UFUNCTION(BlueprintCallable, Category = "PowerUp")
	void StartSpeedBoost(float DurationSeconds = 2.5f, float Force = 1800000.f);

	UFUNCTION(BlueprintCallable, Category = "PowerUp")
	void EndSpeedBoost();

	UFUNCTION(BlueprintCallable, Category = "Score")
	int32 AddScore(int32 Delta);

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostForce = 1000.f;

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostDragScale = 0.6f;

	UPROPERTY(EditAnywhere, Category = "PowerUp")
	float BoostDurationDefault = 2.5f;

	// Allow Checkpoints to update our last checkpoint
	void SetLastCheckpoint(AActor* CheckpointActor) { LastCheckpoint = CheckpointActor; }

private:
	// --- Boost internals ---
	bool bBoostActive = false;
	float SavedDragCoefficient = 0.f;
	FTimerHandle BoostTimer;
	int32 Score = 0;

	// --- Crash + Respawn ---
	// Hit fired by CrashTrigger (or any component we bind)
	UFUNCTION()
	void OnCarHit(UPrimitiveComponent* HitComp, AActor* OtherActor,
		UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);

	// Global actor hit fallback
	UFUNCTION()
	void OnAnyActorHit(AActor* SelfActor, AActor* OtherActor,
		FVector NormalImpulse, const FHitResult& Hit);

	// Overlap fallback (when hits/impulses aren’t generated by the track mesh)
	UFUNCTION()
	void OnCrashTriggerOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
		UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& Sweep);

	UFUNCTION()
	void HandleCarCrash();

	UFUNCTION()
	void RespawnCar();

	// --- FX / settings ---
	UPROPERTY(EditAnywhere, Category = "Crash|Effects")
	UParticleSystem* ExplosionFX = nullptr;

	// Thresholds (tune in editor)
	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float CrashForceThreshold = 80000.f; // impulse from hit

	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float CrashSpeedThreshold = 1800.f;  // cm/s for overlap fallback (~18 m/s ≈ 65 km/h)

	UPROPERTY(EditAnywhere, Category = "Crash|Settings", meta = (ClampMin = "0.0"))
	float RespawnDelay = 2.0f;

	UPROPERTY()
	bool bIsCrashed = false;

	// Last checkpoint to respawn at
	UPROPERTY()
	AActor* LastCheckpoint = nullptr;

	// --- NEW: Fallback to initial spawn if no checkpoint yet ---
	FVector InitialSpawnLocation;
	FRotator InitialSpawnRotation;

	// ================================
	// Respawn improvements / Ghost mode
	// ================================

	// Radius of clear space needed for a valid respawn
	UPROPERTY(EditAnywhere, Category = "Respawn")
	float RespawnClearRadius = 220.f;

	// Number of positions to test for a clear respawn area
	UPROPERTY(EditAnywhere, Category = "Respawn")
	int32 MaxRespawnSearchSteps = 6;

	// Time in seconds the car ignores collisions after respawn
	UPROPERTY(EditAnywhere, Category = "Respawn")
	float GhostTimeAfterRespawn = 1.5f;

	// Horizontal spacing between cars when respawning side by side
	UPROPERTY(EditAnywhere, Category = "Respawn")
	float LaneOffset = 220.f;

	// Forward push applied after respawn to avoid re-contact
	UPROPERTY(EditAnywhere, Category = "Respawn")
	float ForwardNudgeOnRespawn = 300.f;

	// Whether the car is currently ignoring collisions (ghost)
	bool bIsGhost = false;

	// Helper: find a clear respawn spot near the base location
	bool FindSafeRespawnSpot(const FVector& BaseLoc, const FRotator& BaseRot, FVector& OutLoc) const;

	// Helper: get per-player slot for lateral offset (0–3)
	int32 GetRespawnSlot() const;

	// Begin and end temporary ghost mode
	void BeginGhost();
	void EndGhost();
};
